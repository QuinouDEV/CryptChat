{% extends "base.html" %}
{% block content %}

<div class="container">
    <a href="{{ url_for('auth.user_list') }}" class="btn btn-secondary mb-3">Retour</a>
    <meta name="csrf-token" content="{{ csrf_token() }}">

    <h2 class="text-center mt-4">Chat avec {{ receiver.username }}</h2>

    <div class="chat-box" id="chatBox">
        {% for username, msg in messages %}
            <p><strong>{{ username }}:</strong> {{ msg }}</p>
        {% endfor %}
    </div>

    <div class="input-group mt-3">
        <input type="text" id="messageInput" class="form-control" placeholder="Écrire un message..." onkeypress="handleKeyPress(event)">
        <button class="btn btn-success" onclick="sendMessage()">Envoyer</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js"></script>
<script>
    const socket = io();
    const receiverId = "{{ receiver.uuid }}";
    let sharedKeyHex = null;
    const currentUsername = "{{ current_user.username }}";


    async function fetchSharedKey(receiverId) {
        const response = await fetch(`/chat/exchange_key/${receiverId}`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": document.querySelector('meta[name="csrf-token"]').getAttribute('content')
            }
        });
        const data = await response.json();
        if (data.public_key) {
            sharedKeyHex = data.public_key;
        }
    }

    (async () => {
        await fetchSharedKey("{{ receiver.uuid }}");
        initSocketListeners();
    })();

    function hexToBytes(hex) {
        let bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
        return bytes;
    }

    async function decryptMessage(encryptedHex, sharedKeyHex) {
        if (!sharedKeyHex) return "[Clé non disponible]";
        
        const keyBuffer = hexToBytes(sharedKeyHex);
        const key = await crypto.subtle.importKey(
            "raw",
            keyBuffer,
            { name: "AES-CBC" },
            false,
            ["decrypt"]
        );

        let encryptedBytes = hexToBytes(encryptedHex);
        let iv = encryptedBytes.slice(0, 16);
        let encryptedData = encryptedBytes.slice(16);

        try {
            let decryptedBuffer = await crypto.subtle.decrypt(
                { name: "AES-CBC", iv: iv },
                key,
                encryptedData
            );
            return new TextDecoder().decode(decryptedBuffer);
        } catch (e) {
            return "[Message illisible]";
        }
    }

    function initSocketListeners() {
        socket.on("message", async (data) => {
            let chatBox = document.getElementById("chatBox");

            if (!sharedKeyHex) {
                chatBox.innerHTML += `<p><strong>${data.username}:</strong> [Clé non disponible]</p>`;
                return;
            }

            let decryptedMessage = await decryptMessage(data.message, sharedKeyHex);
            chatBox.innerHTML += `<p><strong>${data.username}:</strong> ${decryptedMessage}</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;
        });
    }

    async function encryptMessage(plainText, sharedKeyHex) {
        const keyBuffer = hexToBytes(sharedKeyHex);

        const key = await crypto.subtle.importKey(
            "raw",
            keyBuffer,
            { name: "AES-CBC" },
            false,
            ["encrypt"]
        );

        const iv = crypto.getRandomValues(new Uint8Array(16));
        const encodedText = new TextEncoder().encode(plainText);

        const encryptedBuffer = await crypto.subtle.encrypt(
            { name: "AES-CBC", iv: iv },
            key,
            encodedText
        );

        const combined = new Uint8Array(iv.byteLength + encryptedBuffer.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(encryptedBuffer), iv.byteLength);

        return Array.from(combined).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function sendMessage() {
        let messageInput = document.getElementById("messageInput");
        let message = messageInput.value.trim();

        if (message !== "") {
            let chatBox = document.getElementById("chatBox");
            chatBox.innerHTML += `<p><strong>${currentUsername}:</strong> ${message}</p>`;
            chatBox.scrollTop = chatBox.scrollHeight;

            const encryptedMessageHex = await encryptMessage(message, sharedKeyHex);

            socket.emit("message", {
                message: encryptedMessageHex,
                receiver_id: "{{ receiver.id }}"
            });

            messageInput.value = "";
        }
    }

    function handleKeyPress(event) {
        if (event.key === "Enter") {
            sendMessage();
        }
    }

    function goBack() {
        window.history.back();
    }
</script>

{% endblock %}
